type Analysis
  {
    name: String!
    id: String!
    version: Integer
    categoryIds: [AnalysisCategory]
    description: String
    documentRefs: [DocumentRef]
    reason: String!
    purpose: String!
    analysisSetId: AnalysisSet
    orderedGroupings: [OrderedGroupingFactor]
    dataSubsetId: DataSubset
    dataset: String
    variable: String
    methodId: AnalysisMethod!
    referencedAnalysisOperations: [ReferencedAnalysisOperation]
    results: [OperationResult]
  }

type AnalysisCategorization
  {
    id: String!
    label: String
    categories: [AnalysisCategory]!
  }

type AnalysisCategory
  {
    id: String!
    label: String
    subCategorizations: [AnalysisCategorization]
  }

type AnalysisGroup
  {
    level: Integer
    order: Integer
    condition: WhereClauseCondition
    id: String!
    label: String
    compoundExpression: CompoundGroupExpression
  }

type AnalysisMethod
  {
    name: String!
    id: String!
    label: String
    description: String
    operations: [Operation]!
    codeTemplate: ProgrammingCodeTemplate
  }

type AnalysisSet
  {
    level: Integer
    order: Integer
    condition: WhereClauseCondition
    id: String!
    label: String
    compoundExpression: CompoundSetExpression
  }

type CodeParameter
  {
    name: String!
    description: String
    valueSource: String
  }

type CompoundGroupExpression
  {
    logicalOperator: ExpressionLogicalOperator!
    whereClauses: [Group]
  }

type CompoundSetExpression
  {
    logicalOperator: ExpressionLogicalOperator!
    whereClauses: [AnalysisSet]
  }

type CompoundSubsetExpression
  {
    logicalOperator: ExpressionLogicalOperator!
    whereClauses: [WhereClause]
  }

type DataGroup
  {
    level: Integer
    order: Integer
    condition: WhereClauseCondition
    id: String!
    label: String
    compoundExpression: CompoundGroupExpression
  }

type DataGroupingFactor
  {
    id: String!
    label: String
    groupingVariable: String
    dataDriven: Boolean!
    groups: [DataGroup]
  }

type DataSubset
  {
    level: Integer
    order: Integer
    condition: WhereClauseCondition
    id: String!
    label: String
    compoundExpression: CompoundSubsetExpression
  }

type DisplaySection
  {
    sectionType: DisplaySectionType
    subSections: [DisplaySubSection]
  }

type DisplaySubSection
  {
    id: String!
    order: Integer!
    text: String
  }

type DocumentRef
  {
    referenceDocumentId: ReferenceDocument!
    pageRefs: [PageRef]
  }

type File
  {
    name: String!
    fileType: String
    location: Uri
    style: String
  }

type Group
  {
    level: Integer
    order: Integer
    condition: WhereClauseCondition
    id: String!
    label: String
    compoundExpression: CompoundGroupExpression
  }

interface GroupingFactor
  {
    id: String!
    label: String
    groupingVariable: String
    dataDriven: Boolean!
    groups: [Group]
  }

interface NamedObject
  {
    name: String!
  }

type NestedList
  {
    listItems: [OrderedListItem]
  }

type Operation
  {
    name: String!
    id: String!
    label: String
    referencedOperationRelationships: [ReferencedOperationRelationship]
    resultPattern: String
  }

type OperationResult
  {
    operationId: Operation!
    resultGroups: [ResultGroup]
    rawValue: String
    formattedValue: String
  }

type OrderedDisplay
  {
    order: Integer!
    display: OutputDisplay
  }

type OrderedGroupingFactor
  {
    order: Integer!
    groupingId: GroupingFactor
    resultsByGroup: Boolean!
  }

type OrderedListItem
  {
    name: String!
    level: Integer!
    order: Integer!
    sublist: NestedList
    analysisId: Analysis
    outputId: Output
  }

type Output
  {
    id: String!
    version: Integer
    fileSpecifications: [File]
    displays: [OrderedDisplay]
    categoryIds: [AnalysisCategory]
  }

type OutputDisplay
  {
    name: String!
    id: String!
    version: Integer
    displayTitle: String
    displaySections: [DisplaySection]
  }

type PageNameList
  {
    pageNames: [Integer]!
  }

type PageNameRef
  {
    label: String
    refType: PageRefType!
    pages: PageNameList
  }

type PageNumberList
  {
    pageNumbers: [Integer]!
  }

type PageNumberListRef
  {
    label: String
    refType: PageRefType!
    pages: PageNumberList
  }

type PageNumberRangeRef
  {
    label: String
    refType: PageRefType!
    pages: PageRange
  }

type PageRange
  {
    firstPage: Integer!
    lastPage: Integer!
  }

type PageRef
  {
    refType: PageRefType!
    label: String
    pages: String
  }

type ProgrammingCodeTemplate
  {
    context: String!
    parameters: [CodeParameter]
    templateCode: String
  }

type ReferencedAnalysisOperation
  {
    referencedOperationId: ReferencedOperationRelationship
    analysisId: Analysis!
  }

type ReferenceDocument
  {
    name: String!
    id: String!
    location: Uri
  }

type ReferencedOperationRelationship
  {
    id: String!
    referencedOperationRole: String!
    operationId: Operation!
    analysisId: Analysis
    description: String
  }

type ReportingEvent
  {
    name: String!
    listOfPlannedAnalyses: NestedList!
    listOfPlannedOutputs: NestedList
    analysisSets: [AnalysisSet]
    analysisGroupings: [SubjectGroupingFactor]
    dataSubsets: [DataSubset]
    dataGroupings: [DataGroupingFactor]
    globalDisplaySections: [DisplaySection]
    analysisCategorizations: [AnalysisCategorization]
    analyses: [Analysis]
    methods: [AnalysisMethod]
    outputs: [Output]
    referenceDocuments: [ReferenceDocument]
    terminologyExtentions: [TerminologyExtension]
  }

type ResultGroup
  {
    groupingId: GroupingFactor
    groupId: Group
    groupValue: String
  }

type SponsorTerm
  {
    id: String!
    submissionValue: String!
    description: String
  }

type SubjectGroupingFactor
  {
    id: String!
    label: String
    groupingVariable: String
    dataDriven: Boolean!
    groups: [AnalysisGroup]
  }

type TerminologyExtension
  {
    enumeration: ExtensibleTerminology
    sponsorTerms: [SponsorTerm]!
  }

type WhereClause
  {
    level: Integer
    order: Integer
    condition: WhereClauseCondition
    compoundExpression: WhereClauseCompoundExpression
  }

type WhereClauseCompoundExpression
  {
    logicalOperator: ExpressionLogicalOperator!
    whereClauses: [WhereClause]
  }

type WhereClauseCondition
  {
    dataset: String
    variable: String
    comparator: ConditionComparator
    value: [String]
  }

